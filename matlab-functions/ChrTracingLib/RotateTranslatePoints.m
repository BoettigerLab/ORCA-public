function [ptsOut,imageTiles] = RotateTranslatePoints(ptsIn,theta,varargin)
% ptsIn - Nx2 vector of (x,y) points
% theta - scalar, rotation angle in degrees (not radians)
%       - struct - alignValues struct containing fields theta, xshift,
%                yshift, possibly rescale (ignored) 
% 'center' - default [0,0]. Compute rotation around this point
% 'shifts' - default [0,0]. Translate by this after the rotation
% 'imageTiles' - default empty. apply rotation translation to upper-left
%           tile position and image tile pairs (ul imageTile pairs).
% RotateTranslatePoints(uls,alignValues,'center',[],'imageTiles',imageTiles)
% 
% Notes: currently does not allow rescaling.  Should update like
% ScaleRotateShift, to simplify order of operations and allow more of them.
% 
defaults = cell(0,3);
defaults(end+1,:) = {'center','array',[0,0]};
defaults(end+1,:) = {'shifts','array',[0,0]};
defaults(end+1,:) = {'imageTiles','cell',{}};
defaults(end+1,:) = {'upperLeft','boolean',true};
defaults(end+1,:) = {'invert','boolean',false};
defaults(end+1,:) = {'opOrder',{'TR','RT'},'RT'}; % rotate, then translate
% should generalize to allow rescaling
pars = ParseVariableArguments(varargin,defaults,mfilename);



% alignValues structure passed instead of angle
shifts2 = [0, 0]; % generated by CorrAlignFast multiscale high speed alignment
if isstruct(theta)
    alignValues = theta;
    pars.shifts = [alignValues.xshift,alignValues.yshift]; % for cleanup: inconsistent capitalization xShift vs xshift. 'shifts' vector vs. scalar 
    theta = alignValues.theta;
    if isfield(alignValues,'xshift2')
        shifts2 = [alignValues.xshift2,alignValues.yshift2];
    end
end

% flip direction of originally computed alignment
if pars.invert
   pars.shifts = -pars.shifts;
   theta = - theta;
   % also flip operation order
   if strcmp(pars.opOrder,'RT')
       pars.opOrder = 'TR';
   else
       pars.opOrder = 'RT';
   end
end

shifts = pars.shifts;
cent = pars.center;
imageTiles = pars.imageTiles;


% shift to image centers if using upper left image coords
if ~isempty(imageTiles) && pars.upperLeft
    [h_i,w_i,~] = size(imageTiles{1});
    ptsIn = ptsIn + repmat( [w_i,h_i]/2, size(ptsIn,1), 1); 
end

% tranlation matrix
T1 = [1 0 shifts(1)
     0 1 shifts(2)
     0 0 1     ];
 
 % tranlation matrix
T2 = [1 0 shifts2(1)
     0 1 shifts2(2)
     0 0 1     ];
 
 % rotation matrix around 0,0
R = [cosd(-theta) -sind(-theta)  0
     sind(-theta)  cosd(-theta)  0
          0           0      1];

% Shift to center matrix (to rotate arond point 'cent').
P = [1 0 -cent(1)
     0 1 -cent(2)
     0 0 1];
 

% the full operation,
if strcmp(pars.opOrder,'RT') % rotate, then translate
    U = T2*T1*inv(P)*R*P;
    % U = T2*T1*P\R*P; % matlab thinks this is faster and more accurate
else
    % the full operation, translation first:    
    U = T2*inv(P)*R*P*T1;
    % U = T2*P\R*P*T1; % matlab thinks this is faster and more accurate
end
% S = T1*R*inv(T1); % b*inv(A) = b/A
npts = size(ptsIn,1);
data = [ptsIn'; ones(1,npts)];
vals = U*data;
ptsOut = vals(1:2,:)';

if ~isempty(imageTiles)
    [nTiles,nChns] = size(imageTiles);
    for n=1:nTiles
        for c=1:nChns
            imageTiles{n,c} = imrotate(imageTiles{n,c},theta,'bilinear','crop');
        end
    end
    % shift back to upper-left coordinates if these were used
    if pars.upperLeft
       ptsOut = ptsOut - repmat( [w_i,h_i]/2, size(ptsIn,1), 1); 
    end
end
